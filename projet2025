import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from scipy.integrate import solve_ivp

# -------------------------------
# üß† PARAM√àTRES 
# -------------------------------
L = 7.0
g = 9.81
m = 5.0
m_b = 5.0
k_h = 20.0
k_v = 30.0
l_h0 = 1.0
l_v0 = 1.0
c_theta = 0.9
c_mu = 0.9
damping=0.6 # Coefficient d'amortissement
epsilon_angle = 1e-3 # Petite marge pour les angles limites
temps1=0 # Variable pour stocker le temps pr√©c√©dent
# -------------------------------
# üìê √âQUATIONS DU SYST√àME 
# -------------------------------
def ode_system(t, Y):
    theta, theta_dot, mu, mu_dot = Y
    c = np.cos(theta)
    s = np.sin(theta)
    

    M11 = (m_b / 3.0) * L**2 + m * (L * c)**2
    M12 = -m * L * c
    M21 = -m * L * c
    M22 = m

    # ... (F1 inchang√©)
    F1 = (- (m_b / 2.0 + m) * g * L * c
          + k_h * (L * c - l_h0) * L * s
          - m * (L * s * theta_dot)**2
          - c_theta * theta_dot
          - damping * L**2 * s**2 * theta_dot)

    # ---- V√âRIFIEZ ATTENTIVEMENT CETTE PARTIE ----
    F2 = (m * g
          - k_v * (mu - l_v0)     # <--- ASSUREZ-VOUS QUE CETTE LIGNE EST IDENTIQUE
          + m * L * s * theta_dot**2
          - c_mu * mu_dot)
    # ----------------------------------------------

    det_M = M11 * M22 - M12 * M21
    if abs(det_M) < 1e-12:
        return np.array([theta_dot, 0, mu_dot, 0])

    inv_det_M = 1.0 / det_M
    theta_ddot = inv_det_M * (M22 * F1 - M12 * F2)
    mu_ddot = inv_det_M * (-M21 * F1 + M11 * F2)

    return np.array([theta_dot, theta_ddot, mu_dot, mu_ddot])
# -------------------------------
# üîî D√âFINITION DES √âV√âNEMENTS POUR LES CONTRAINTES
# -------------------------------

# √âv√©nement 1: La masse touche le sol (y_m = 0)
def event_ground_contact(t, Y):
    theta, _, mu, _ = Y
    return L * np.sin(theta) - mu  # Position verticale de la masse
event_ground_contact.terminal = True  # Arr√™ter l'int√©gration
event_ground_contact.direction = -1  

# √âv√©nement 2: Le ressort vertical s'√©crase (mu = 0)
def event_mu_zero(t, Y):
    return Y[2] # mu
event_mu_zero.terminal = True
event_mu_zero.direction = -1

# √âv√©nement 3: La barre atteint l'angle minimal
def event_angle_min(t, Y):
    return Y[0] - epsilon_angle # theta
event_angle_min.terminal = True
event_angle_min.direction = -1

# √âv√©nement 4: La barre atteint l'angle maximal
def event_angle_max(t, Y):
    return (np.pi/2 - epsilon_angle) - Y[0] # theta
event_angle_max.terminal = True
event_angle_max.direction = -1


# -------------------------------
# ‚öôÔ∏è INT√âGRATION NUM√âRIQUE AVEC SOLVE_IVP ET GESTION D'√âV√âNEMENTS
# -------------------------------
# Conditions initiales
theta0 = np.pi / 3
theta_dot0 = 0.0
mu0 = 1.2
mu_dot0 = 0.0
y0 = np.array([theta0, theta_dot0, mu0, mu_dot0])

# Param√®tres de simulation
t_start = 0
T_max = 100.0 
t_eval_points = 1000 

# Listes pour stocker les morceaux de la solution entre les √©v√©nements
# ---- CORRECTIONS ICI ----
t_solution = [np.array([t_start])]       # Fix 1: Initialise t_solution comme un array 1D
y_solution = [y0.reshape(-1, 1)]         # Fix 2: Initialise y_solution comme un array 2D (vecteur colonne)

current_t = t_start
y_current = y0

print("D√©but de l'int√©gration avec solve_ivp...")

while current_t < T_max:
    t_span = [current_t, T_max]
    
    sol = solve_ivp(
        fun=ode_system, 
        t_span=t_span, 
        y0=y_current, 
        method='RK45',
        events=[event_ground_contact, event_mu_zero, event_angle_min, event_angle_max],
        rtol=1e-6, 
        atol=1e-8
    )
   
    # On ajoute le segment de solution seulement s'il contient de nouveaux points
    if sol.t.size > 1:
        t_solution.append(sol.t[1:])
        y_solution.append(sol.y[:, 1:]) # sol.y est d√©j√† en 2D, c'est bon
    
    current_t = sol.t[-1]

    if sol.status == 1: # Un √©v√©nement a √©t√© d√©clench√©
        y_last = sol.y[:, -1].copy()
        
        # Logique de rebond
        if sol.t_events[0].size > 0:
            
            
            prcdtemps = temps1
            temps1 = current_t
            
            if temps1 - prcdtemps < 0.25:
                print("barre au sol ")
                break

            theta, theta_dot, mu, mu_dot = y_last
            
            if l_v0 >= mu :  # ressort √©cras√© ou en quasi-contact
                # Rebond collectif barre + masse
                y_last[0] += 0.001  # l√©g√®re s√©paration angulaire
                y_last[1] = -y_last[1] * 0.9
                y_last[3] = -y_last[3] * 0.9


                print("Rebond complet : masse + barre")
           # Nouveau code corrig√©
            if mu > l_v0:
                theta, theta_dot, mu, mu_dot = y_last
                
                # 1. Calculer la vitesse verticale ABSOLUE
                v_vertical_abs = L * np.cos(theta) * theta_dot - mu_dot
                
                # 2. Inverser avec amortissement (coefficient 0.9)
                v_vertical_abs_new = -0.9 * v_vertical_abs
                
                # 3. Recalculer mu_dot (theta_dot reste inchang√©)
                mu_dot_new = L * np.cos(theta) * theta_dot - v_vertical_abs_new
                
                # 4. Ajuster la position (l√©g√®rement au-dessus du sol)
                mu_new = L * np.sin(theta) * 0.98
                
                # 5. Mettre √† jour l'√©tat
                y_last[2] = mu_new
                y_last[3] = mu_dot_new
                
                print("Rebond masse seule")

    # Ne jamais modifier y_last[2] ici, c'est mu (hauteur relative)

        

        elif sol.t_events[1].size > 0:
            print(f"INFO: Contact masse-barre (mu=0) √† t={current_t:.2f}s")
            y_last[2] = 0
            y_last[3] = -0.9 * y_last[3]
        elif sol.t_events[2].size > 0:
            print(f"INFO: Rebond sur le mur vertical √† t={current_t:.2f}s")
           
            y_last[0] = epsilon_angle+0.1
            y_last[1] = -0.9 * y_last[1]
        elif sol.t_events[3].size > 0:
            print(f"INFO: Rebond sur le mur horizontal √† t={current_t:.2f}s")
            
            y_last[0] = y_last[0]+0.001
            y_last[1] = -y_last[1]*0.9

        y_current = y_last
    else: # L'int√©gration a atteint T_max sans √©v√©nement
        break

print("Fin de l'int√©gration.")

# Concat√©ner tous les segments de solution en un seul tableau
# Cette partie fonctionnera maintenant car tous les tableaux ont 2 dimensions
t_vals = np.concatenate(t_solution)
Y_vals = np.hstack(y_solution).T

# √âchantillonner la solution √† des points de temps r√©guliers
t_eval = np.linspace(t_start, t_vals[-1], t_eval_points)
Y_eval = np.array([np.interp(t_eval, t_vals, Y_vals[:, i]) for i in range(4)]).T


# -------------------------------
# üìä POST-TRAITEMENT ET GRAPHIQUES (avec les donn√©es √©chantillonn√©es)
# -------------------------------
theta = Y_eval[:, 0]
theta_dot = Y_eval[:, 1]
mu = Y_eval[:, 2]
mu_dot = Y_eval[:, 3]

# Calcul des √©nergies pour validation
T_barre = 1/6 * m_b * L**2 * theta_dot**2
T_masse = 0.5 * m * (L * np.cos(theta) * theta_dot - mu_dot)**2
T_totale = T_barre + T_masse

V_g = m_b * g * L/2 * np.sin(theta) + m * g * (L * np.sin(theta) - mu)
V_e = 0.5 * k_h * (L * np.cos(theta) - l_h0)**2 + 0.5 * k_v * (mu - l_v0)**2
V_totale = V_g + V_e

E_totale = T_totale + V_totale

# -------------------------------
# ANIMATION
# -------------------------------
fig, ax = plt.subplots(figsize=(6, 6))
ax.set_xlim(-L * 0.2, L + 1)
ax.set_ylim(-0.5, L + 1)
ax.set_aspect('equal')
ax.set_title("Animation du syst√®me avec amortissement et contraintes")

bar_line, = ax.plot([], [], 'k-', lw=3)
spring1_line, = ax.plot([], [], 'r--', lw=2)
spring2_line, = ax.plot([], [], 'b--', lw=2)
mass_point, = ax.plot([], [], 'ko', markersize=10)

def init():
    return bar_line, spring1_line, spring2_line, mass_point

def animate(i):
    th = theta[i]
    mu_i = mu[i]

    x1 = L * np.cos(th)
    y2 = L * np.sin(th)
    y3 = L * np.sin(th)-mu_i 

    bar_line.set_data([0, x1], [y2, 0])
    spring1_line.set_data([0, 0], [y2, y3])
    spring2_line.set_data([0, x1], [0, 0])
    mass_point.set_data(0, y3)

    return bar_line, spring1_line, spring2_line, mass_point

ani = FuncAnimation(fig, animate, frames=len(theta), init_func=init,
                    blit=True, interval=20)
plt.show()
# GRAPHIQUES
plt.figure(figsize=(15, 8))
plt.suptitle("R√©sultats de la simulation avec solve_ivp et gestion d'√©v√©nements", fontsize=16)

plt.subplot(2, 3, 1)
plt.plot(t_eval, np.rad2deg(theta))
plt.title("Angle Œ∏ de la barre (¬∞)")
plt.xlabel("Temps (s)")
plt.grid(True)

plt.subplot(2, 3, 2)
plt.plot(t_eval, mu)
plt.title("Longueur du ressort vertical (m)")
plt.xlabel("Temps (s)")
plt.grid(True)

plt.subplot(2, 3, 3)
plt.plot(t_eval, L * np.sin(theta) - mu)
plt.title("Position verticale de la masse (m)")
plt.xlabel("Temps (s)")
plt.axhline(0, color='r', linestyle='--')
plt.grid(True)

plt.subplot(2, 3, 4)
plt.plot(t_eval, T_totale, label='Cin√©tique (T)')
plt.plot(t_eval, V_totale, label='Potentielle (V)')
plt.legend()
plt.title("√ânergies")
plt.xlabel("Temps (s)")
plt.grid(True)

plt.subplot(2, 3, 5)
plt.plot(t_eval, E_totale)
plt.title("√ânergie M√©canique Totale (T+V)")
plt.xlabel("Temps (s)")
plt.grid(True)

plt.subplot(2, 3, 6)
plt.plot(t_eval, L * np.cos(theta))
plt.title("Longueur du ressort horizontal")
plt.xlabel("Temps (s)")
plt.grid(True)

plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.show()




# -------------------------------
# üìà GRAPHIQUES SUPPL√âMENTAIRES ET ANALYSES
# -------------------------------

# 1. Conversion en variables sans dimension pour l'analyse
tau = t_eval * np.sqrt(g / L)  # Temps sans dimension
mu_nd = mu / L                 # Longueur Œº sans dimension
theta_nd = theta               # Angle Œ∏ d√©j√† sans dimension
theta_dot_nd = theta_dot * np.sqrt(L / g)  # D√©riv√©e dŒ∏/dt sans dimension
mu_dot_nd = mu_dot / np.sqrt(g * L)       # D√©riv√©e dŒº/dt sans dimension

# Param√®tres sans dimension (calcul√©s √† partir des param√®tres physiques)
alpha = (k_v * L) / (m * g)
beta = k_h * L / (m * g)
gamma = m / (m_b / 3 + m)
lambda1 = l_v0 / L
lambda2 = l_h0 / L

# 2. Calcul des grandeurs suppl√©mentaires pour les graphiques
# √ânergie sans dimension et sa variation
E_nd = E_totale / (m * g * L)
delta_E = E_nd - E_nd[0]

# Hauteur de la masse et allongement du ressort
height_mass = (L * np.sin(theta) - mu) / L
elong_horiz = -(np.cos(theta) - lambda2)

# 3. Cr√©ation des graphiques suppl√©mentaires
plt.figure(figsize=(14, 10))

# Graphique 1: √âtats du syst√®me
plt.subplot(3, 2, 1)
plt.plot(tau, theta_nd, label='Œ∏(œÑ)')
plt.plot(tau, mu_nd, label='Œº(œÑ)')
plt.xlabel("œÑ (temps sans dimension)")
plt.ylabel("√âtats du syst√®me")
plt.title("√âvolution de Œ∏(œÑ) et Œº(œÑ)")
plt.legend()
plt.grid()

# Graphique 2: Variation d'√©nergie
plt.subplot(3, 2, 2)
plt.plot(tau, delta_E, label='ŒîE = E(œÑ) - E(0)')
plt.xlabel("œÑ")
plt.ylabel("Variation d'√©nergie")
plt.title("Conservation de l'√©nergie")
plt.grid()
plt.legend()

# Graphique 3: Vitesse angulaire
plt.subplot(3, 2, 3)
plt.plot(tau, theta_dot_nd, label="Œ∏Ãá(œÑ)", color='tab:orange')
plt.xlabel("œÑ")
plt.ylabel("Vitesse angulaire")
plt.title("Vitesse Œ∏Ãá(œÑ)")
plt.legend()
plt.grid()

# Graphique 4: Vitesse verticale
plt.subplot(3, 2, 4)
plt.plot(tau, mu_dot_nd, label="ŒºÃá(œÑ)", color='tab:green')
plt.xlabel("œÑ")
plt.ylabel("Vitesse ŒºÃá(œÑ)")
plt.title("Vitesse verticale ŒºÃá(œÑ)")
plt.legend()
plt.grid()

# Graphique 5: Hauteur de la masse
plt.subplot(3, 2, 5)
plt.plot(tau, height_mass, label="Hauteur de la masse m", color='tab:red')
plt.xlabel("œÑ")
plt.ylabel("Hauteur (sans dimension)")
plt.title("Hauteur de la masse suspendue par rapport au sol")
plt.grid()
plt.legend()

# Graphique 6: Allongement ressort horizontal
plt.subplot(3, 2, 6)
plt.plot(tau, elong_horiz, label="Allongement ressort horizontal", color='tab:purple')
plt.xlabel("œÑ")
plt.ylabel("Allongement (sans dimension)")
plt.title("Allongement du ressort horizontal")
plt.grid()
plt.legend()

plt.tight_layout()
plt.show()

from scipy.signal import find_peaks

def fourier_analysis_dual_with_peaks(signal1, signal2, t, label1, label2, n_peaks=3):
    N = len(t)
    dt = t[1] - t[0]
    freq_nd = np.fft.fftfreq(N, dt)
    signal1 = signal1 - np.mean(signal1)
    signal2 = signal2 - np.mean(signal2)
    # FFTs
    fft1 = np.abs(np.fft.fft(signal1))
    fft2 = np.abs(np.fft.fft(signal2))
    
    # Conversion en Hz
    freq_Hz = freq_nd * (1/(2*np.pi)) * np.sqrt(g/L)
    
    # Garde uniquement les fr√©quences > 0
    mask = freq_Hz > 0
    freq_Hz = freq_Hz[mask]
    fft1 = fft1[mask]
    fft2 = fft2[mask]
    
    # Trouve les pics
    peaks1, _ = find_peaks(fft1, height=np.max(fft1)*0.1)
    peaks2, _ = find_peaks(fft2, height=np.max(fft2)*0.1)
    
    # Trie et s√©lectionne les pics les plus forts
    top_peaks1 = peaks1[np.argsort(fft1[peaks1])[-n_peaks:]]
    top_peaks2 = peaks2[np.argsort(fft2[peaks2])[-n_peaks:]]
    
    # Trac√©
    plt.figure(figsize=(10, 5))
    plt.plot(freq_Hz, fft1, label=label1)
    plt.plot(freq_Hz, fft2, label=label2)
    
    plt.plot(freq_Hz[top_peaks1], fft1[top_peaks1], 'o', label=f"Pics {label1}")
    plt.plot(freq_Hz[top_peaks2], fft2[top_peaks2], 's', label=f"Pics {label2}")
    
    for i in top_peaks1:
        plt.text(freq_Hz[i], fft1[i], f"{freq_Hz[i]:.2f} Hz", ha='right', va='bottom', fontsize=8)
    for i in top_peaks2:
        plt.text(freq_Hz[i], fft2[i], f"{freq_Hz[i]:.2f} Hz", ha='left', va='bottom', fontsize=8)
    
    plt.xlabel("Fr√©quence (Hz)")
    plt.ylabel("Amplitude")
    plt.title("Analyse de Fourier avec pics dominants")
    plt.legend()
    plt.grid()
    plt.tight_layout()
    plt.show()

# Utilisation
fourier_analysis_dual_with_peaks(theta_nd, mu_nd, tau, "Œ∏(œÑ)", "Œº(œÑ)")


# 6. Lin√©arisation et comparaison avec mod√®le non-lin√©aire
def linearized_ode(t, y):
    theta, theta_dot, mu, mu_dot = y
    I = (m_b * L**2)/3 + m * L**2  # Moment d'inertie
    
    # Termes lin√©aris√©s
    theta_ddot = (- (m_b/2 + m) * g * L * theta / I 
                 + k_h * L**2 * theta / I
                 - c_theta * theta_dot / I)
    
    mu_ddot = (m * g - k_v * (mu - l_v0) 
              - c_mu * mu_dot)/m
    
    return [theta_dot, theta_ddot, mu_dot, mu_ddot]
# R√©soudre analytiquement l'√©quilibre
from scipy.optimize import fsolve

def equilibrium_eq(vars):
    theta_eq, mu_eq = vars
    eq1 = (m_b/2 + m)*g*L*np.cos(theta_eq) - k_h*(L*np.cos(theta_eq) - l_h0)*L*np.sin(theta_eq)
    eq2 = m*g - k_v*(mu_eq - l_v0)
    return [eq1, eq2]

theta_eq_0 = np.pi/4  # Valeur initiale
mu_eq_0 = l_v0 + m*g/k_v  # Valeur initiale
theta_eq, mu_eq = fsolve(equilibrium_eq, (theta_eq_0, mu_eq_0))
# Conditions initiales proches de l'√©quilibre

y0_lin = [theta_eq, 0.0, mu_eq, 0.0]

# R√©solution du syst√®me lin√©aire
sol_lin = solve_ivp(linearized_ode, [t_start, 10], y0_lin, 
                    t_eval=np.linspace(t_start, 10, 1000), 
                    method='RK45', rtol=1e-10)

# R√©solution du syst√®me non-lin√©aire (m√™mes CI)
sol_nl = solve_ivp(ode_system, [t_start, 10], y0_lin, 
                   t_eval=np.linspace(t_start, 10, 1000), 
                   method='RK45', rtol=1e-10)
# Extraction des r√©sultats
t_lin = sol_lin.t
theta_lin = sol_lin.y[0]
mu_lin = sol_lin.y[2]

t_nl = sol_nl.t
theta_nl = sol_nl.y[0]
mu_nl = sol_nl.y[2]

# Calcul des erreurs

from scipy.interpolate import interp1d
# Interpolation de theta_nl (116 points) sur les temps t_lin (1000 points)
interp_theta_nl = interp1d(t_nl, theta_nl, kind='linear', fill_value="extrapolate")
theta_nl_interp = interp_theta_nl(t_lin)  # Maintenant, theta_nl_interp a la m√™me taille que theta_lin

# Interpolation de mu_nl sur la grille de t_lin
interp_mu_nl = interp1d(t_nl, mu_nl, kind='linear', fill_value="extrapolate")
mu_nl_interp = interp_mu_nl(t_lin)

error_theta = np.abs(theta_lin - theta_nl_interp)
#error_theta = np.abs(theta_lin - theta_nl)
error_mu = np.abs(mu_lin - mu_nl_interp)

# Trac√© des erreurs
plt.figure(figsize=(10, 5))
plt.plot(t_lin, error_theta, label='Erreur |Œ∏_lin - Œ∏_nl|')
plt.plot(t_lin, error_mu, label='Erreur |Œº_lin - Œº_nl|')
plt.yscale('log')
plt.xlabel("Temps (s)")
plt.ylabel("Erreur absolue (log)")
plt.title("Erreur entre solution lin√©aire et non-lin√©aire")
plt.legend()
plt.grid()
plt.tight_layout()
plt.show()

# 7. Identification du point d'√©quilibre
print(f"Point d'√©quilibre trouv√© : Œ∏ = {theta[-1]:.4f} rad, Œº = {mu[-1]:.4f} m")
# 8. Test de convergence



# ----------------------------------------
#  TEST DE CONVERGENCE DU SCH√âMA NUM√âRIQUE
# ----------------------------------------

# Conditions initiales identiques √† celles utilis√©es plus haut
y0_conv = [np.pi / 3, 0.0, 1.2, 0.0]
t_span_conv = [0, 10]
t_eval_conv = np.linspace(t_span_conv[0], t_span_conv[1], 1000)

# Tol√©rances √† tester
tolerances = [1e-3, 1e-5, 1e-7, 1e-9]

# Stockage des solutions pour comparer
solutions = []

print("D√©but du test de convergence...")

for tol in tolerances:
    sol = solve_ivp(
        ode_system,
        t_span=t_span_conv,
        y0=y0_conv,
        method='RK45',
        t_eval=t_eval_conv,
        rtol=tol,
        atol=tol
    )
    solutions.append(sol)
    print(f"‚Üí R√©solu avec tol√©rance rtol=atol={tol}")

# Solution la plus pr√©cise comme r√©f√©rence
Y_ref = solutions[-1].y  # La derni√®re, avec la tol√©rance la plus petite

# Calcul des erreurs pour les autres tol√©rances (par rapport √† la r√©f√©rence)
errors = []

for i in range(len(tolerances) - 1):
    Y_i = solutions[i].y
    err = np.linalg.norm(Y_i - Y_ref, axis=0) / np.linalg.norm(Y_ref, axis=0)
    errors.append(np.mean(err))

# Trac√© de l'erreur moyenne en fonction de la tol√©rance (log-log)
plt.figure(figsize=(8, 5))
plt.loglog(tolerances[:-1], errors, marker='o')
plt.xlabel("Tol√©rance rtol=atol")
plt.ylabel("Erreur relative moyenne")
plt.title("Test de convergence du sch√©ma RK45")
plt.grid(True, which="both", ls="--")
plt.tight_layout()
plt.show()

# ----------------------------------------
# üîã TEST DE CONSERVATION DE L'√âNERGIE
# ----------------------------------------
Œ± = (m_b * L**2 / 3) / (m * L**2)   # inertie bar / masse suspendue
Œ≤ = k_v / (m * g)                   # raideur vertical / poids
def energie_totale(t, y):
    Œ∏, Œ∏_dot, Œº, Œº_dot = y
    # Expressions extraites de ton syst√®me adimensionn√©
    Œ∏_dot2 = Œ∏_dot**2
    Œº_dot2 = Œº_dot**2

    # √ânergies cin√©tique et potentielle (adimensionn√©es)
    E_kin = 0.5 * (Œ± * Œ∏_dot2 + Œº_dot2)
    E_pot = Œ± * (1 - np.cos(Œ∏)) + Œ≤ * (Œº - 1)**2 + Œº

    return E_kin + E_pot

# Calcul de l‚Äô√©nergie totale pour chaque tol√©rance
energies = []

for sol in solutions:
    E = np.array([energie_totale(t, y) for t, y in zip(sol.t, sol.y.T)])
    energies.append(E)

# Trac√© de l‚Äô√©nergie pour chaque tol√©rance
plt.figure(figsize=(10, 6))

for i, E in enumerate(energies):
    plt.plot(solutions[i].t, E, label=f'rtol=atol={tolerances[i]:.0e}')

plt.xlabel("Temps")
plt.ylabel("√ânergie totale (adimensionn√©e)")
plt.title("Conservation de l'√©nergie selon la tol√©rance")
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()
